#! /usr/bin/env python3
# -*- coding: <utf-8> -*-

"""qualcity.

Usage:
    qualcity (-h | --help)
    qualcity pipeline <pipline_conf> [logger <log_conf>] [(-v | --verbose)]

Options:
    -h --help           Show this screen.
    -v --verbose        Verbose mode

"""

import docopt

import operator

import yaml

import logging
import logging.config

import matplotlib.pyplot as plt

import city.features
import city.labels
import city.learning
import city.utils
import city.config


logger = logging.getLogger('qualcity')

def config_logger(arguments):
    if not arguments['logger']:
        logging.config.dictConfig(city.config.logger_default)
        logger.info('Default logger chosen.')
    else:
        with open(arguments['<log_conf>'], mode='r') as conf:
            configuration = yaml.load(conf)

        configuration['handlers']['file']['filename'] = (
            'qualcity-' + time.ctime() + '.log'
        )
        configuration['loggers']['qualcity']['level'] = (
            'DEBUG' if arguments['--verbose'] else 'INFO'
        )
        logging.config.dictConfig(
            configuration
        )
        logger.info('Loaded logger from: ' + arguments['<log_conf>'])
        logger.debug(yaml.dump(configuration))


def get_labels(hierarchical, depth, LoD, threshold, labels_path, filetype):
    logger.info('Getting Labels ...')
    return [
        (building, label)
        for building, label in sorted(
            city.labels.labels_map(
                labels_path,
                hierarchical,
                depth,
                LoD,
                threshold,
                filetype
            ).items(),
            key=operator.itemgetter(0)
        )
    ]


def format_labels(hierarchical, depth, LoD, threshold, labels_path, filetype):
    logger.info('Formatting labels')
    labels = get_labels(
        hierarchical,
        depth,
        LoD,
        threshold,
        labels_path,
        filetype
    )
    if depth > 0:
        labels = [
            (building, label)
            for building, label in labels
            if label != 'Unqualifiable'
        ]
    return zip(*labels)


def build_reductor(algorithm, **parameters):
    logger.info('Building a dimension reductor...')

    if parameters['n_components'] > 3:
        logger.error('Cannot visualize more than three dimensions!')
        raise ValueError
    elif parameters['n_components'] < 2:
        logger.error('Cannot visualize less than two dimensions!')
        raise ValueError

    return city.utils.resolve(algorithm)(
        **parameters
    )


def visualize(features, labels, label_names, **visualization_args):
    logger.info('Feature space visualization.')
    city.features.visualize_features(
        features,
        labels,
        label_names,
        build_reductor(
            visualization_args['dimension_reduction']['algorithm'],
            **visualization_args['dimension_reduction']['parameters']
        ),
        visualization_args['dimension_reduction']['parameters']['n_components'],
        **visualization_args['style']
    )
    logger.info('Visualization process ended.')


def process(features, labels, buildings, label_names, **process_args):
    logger.info('Processing features...')
    if 'visualization' in process_args.keys():
        visualize(
            features,
            labels,
            label_names,
            **process_args['visualization']
        )

    city.learning.classify(
        features,
        labels,
        buildings,
        label_names,
        **process_args['classification']
    )
    logger.info('Succesfully classified features.')
    plt.show()


def load_pipeline_config(pip_conf):
    logger.info('Loading pipeline configuration file...')
    with open(pip_conf, mode='r') as conf:
        return yaml.load(conf)


def label_names(config, labels):
    if config['depth'] < 2:
        return tuple(set(labels))
    elif config['depth'] == 2:
        return (
            tuple(set(labels)) if config['hierarchical']
            else ['Building', 'Facet']
        )
    elif config['depth'] == 3:
        return (
            {
                'Valid': None,
                'Building': city.labels.LABELS(
                    config['LoD'],
                    ['Building']
                ),
                'Facet': city.labels.LABELS(
                    config['LoD'],
                    ['Facet']
                )
            } if config['hierarchical']
            else city.labels.LABELS(
                config['LoD'],
                ['Building', 'Facet']
            )
        )
    else:
        raise LookupError('depth cannot be > 3')


def main():
    arguments = docopt.docopt(
        __doc__,
        help=True,
        version=city.config.__version__,
        options_first=False
    )

    config_logger(arguments)

    configuration = load_pipeline_config(arguments['<pipline_conf>'])
    logger.info('Pipeline loaded.')

    buildings, labels = format_labels(
        **configuration['labels']
    )
    logger.debug(
        'There are %s buildings. Buildings are: %s',
        len(buildings),
        buildings
    )
    logger.debug('Labels are: %s', labels)
    logger.info('Labels safely loaded.')

    features = city.features.get_features(
        buildings,
        **configuration['features']['types']
    )
    logger.debug(features)
    logger.info('Features safely loaded.')

    if 'manifold' in configuration['features']:
        features = city.features.transform(
            features,
            **configuration['features']['manifold']
        )
    logger.debug(features)
    logger.info('Features safely transformed.')

    process(
        features,
        labels,
        buildings,
        label_names(
            configuration['labels'],
            labels
        ),
        **configuration['processing']
    )


if __name__ == '__main__':
    main()
